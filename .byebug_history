c
view
name
c
up
s
self.name
self
n
name
c
name
n
s
n
s
n
s
name
n
s
n
s
n
first_active_substate
n
c
name
c
name
c
name
c
name
c
self
args
c
new_substate
new_substate.name
new_substate
down
up
state.name.class
state.name
s
new_substate
c
down
up
c
def cal(opt); p opt.class ;end
def cal(opt) p opt.class ;end;
def cal(opt) p opt.class ;end;)
def cal(opt) p opt.class ;end; cal(->() {})
def cal(opt) p opt.class ;end; cal(->() {}))
pr = (&(->() {}))
pr = (&->() {})
pr = &->() {}
opts
c
opts[:concurrentdf]
opts[:concurrent]
opts
n
s
callback
opts
down
up
c
opts[:concurrent]
c
n
opts[:concurrent]
opts[:concurrent
opts
c
self.name
self
@can_exit
c
@can_exit
n
c
n
root.all_active_paths
n
next_state
n
__is_current__?
name
n
name
states.first.path_states.map(&:name)name
selflen
states.first.path_states.map(&:name)
states.map(&:name)
nexts
nexts.map(&:name)
n
current_active_substate = cur
cur
current_active_substate
n
path_states.map(&:name)
n
states.first.name
states.name
self.name
s
n
next_state.name
next_state
n
current_active_substate = cur
next_state.name
next_state
n
nexts.map(&:name)
nexts
n
substates.find {|state| state.__is_current__? }
n
path_states.size
states.map(&:name)
self.name
self
s
states.map(&:name)
s
substate.name
valid_destination_states.map(&:name)
n
substate.name
substate.find_pivot(d_state).name
d_state.name
d_state
n
s
substate.name
d_state.name
destination_states.map(&:name)
substate.name
d_state.view
d_state.name
d_state
s
n
valid_destination_states.map(&:name)
vlaid_destination_states.map(&:name)
n
d_state.name
substate.name
s
n
c
destination_states.map(&:name)
finish
s
substate.find_pivot(d_state).name
substate.name
name
d_state.name
d_state
up
s
substate.name
substate.find_pivot(d_state).name
substate.find_pivot(d_state)
substate.find_pivot(d_state
substate.name
destination_states.map(&:name)
d_state.name
substate.name
substate
s
n
s
n
c
name
n
destination_states.map(&:name)
c
states
name
c
name
next_state.name
c
s
n
enter_col
s
n
@enters
n
view
name
n
self.view
self.name
self
c
view
name
c
s
n
@enters
@enter
self.name
c
self.name
self.view
self.name
self
c
stateA
substates.map(&:name)
substates
@enters
s
n
name
c
self.root.view
self.root.substates.map(&:name)
self.root.substates.size
self.root.substates
self.root.enters
self.root
self.substates
self.substatess
self.name
self
@enters
n
__is_current__?
self.name
self.anme
n
@enters
s
n
@enters
self.__is_current__?
next_state.name
next_state
self.name
self
state
c
self.name
allback

c
self.name
destination_states
up
u
states
substates.map(&:name)
substates
c
states
path_states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
c
states
stsates
c
states
continue
!
!!!
x
exit
c
s
c
s
c
s
n
cur
n
c
s
n
__is_current__?
s
name
s
next_state = next_state_path
next_state
n
next_state_path
n
c
next_state_path
 (next_state_path = nexts.first) && @substates.any?
n
nexts
n
c
n
c
@substates.first
@substates
s
n
nn
n
c
s
name
@__is_current__
n
@__is_current__
n
c
state_concurrent.substates.map(&:name)
state_concurrent.concurrent?
state_concurrent.superstate === root
state_concurrent.superstate == root
root
n
c
s
n
nn
n
c
prev
previous
source
show
context
info
frame
help
history
help
show
source
help
var
help
where
whereami
code
@
root
n
s
n
s
n
s
n
c
n
next_state_path
self.name
s
n
nnnnnnn
n
s
n
s
n
s
n
c
n
s
n
c
n
s
n
c
s
n
s
n
c
n
puts states.first
p states.first
p states
s
states.map(&:name)
states.size
states.len
n
cur
next_state_path.name
next_state_path.namme
next_state_path
n
s
n
nexts.map(&:name)
nexts.length
nexts
next
n
@substates.first.__is_current__?
@substates.first.__is_current?__
@substates.size
@substates
n
self.name
states.map(&:name)
states.size
states
s
n
s
n
@superstate
n
pivot.name
pivot
n
uniq_states(pivots).size
uniq_states(pivots)
unique_states(pivots)
unique_state(pivots)
pivots.length
pivots
n
c
pivots
n
pivots
n
paths
opts
paths
n
paths_and_opts
c
s
c
true
finish
help
pivot.all_active_states
pivot.current
state.current
opts
states
pivot.name
pivot
c
self.superstate.__is_current__?
self.superstate.__is_current__
self.superstate.name.__is_current__
self.superstate.name.__is_current__?
self.superstate.name.__is_current?__
self.superstate.name
self.superstate
self.name
self.__is_current__?
self.__is_current__
__is_current__?
s
self.name
c
n
self.name
self
c
callback
c
@substate_map
@state_map
n
state.name
state
s
@stateA
c
